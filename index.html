<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      overflow: hidden;
      margin: 0;
      padding: 0;
    }

    canvas {
      display: block;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <title>Generative Art</title>
</head>
<body>
  <script>
    // Constants
    const NOISE_INCREMENT = 0.1;
    const MAX_ALPHA = 100;
    const FADE_SPEED = 0.015;
    let speedMultiplier = 1;
    const SPEED_CHANGE_RATE = 0.1;
    let rainbowMode = false;
    let lastPaletteChangeTime = 0;
    const RAINBOW_MODE_INTERVAL = 7500; // 7.5 seconds in milliseconds

    // Variables
    let cols, rows;
    let scl = 20;
    let w, h;
    let flowfield = [];
    let dots = [];
    let terrain = [];
    let baseColors = [
      [225, 90, 90],
      [0, 180, 0],
      [140, 180, 255],
      [170, 120, 200],
      [255, 200, 200],
      [255, 215, 0],
      [255, 165, 0],
      [169, 169, 169],
      [255, 150, 0],
      [0, 150, 255],
      [255, 100, 150],
      [255, 50, 120],
      [100, 200, 100]
    ];
    let currentPaletteIndex = 0;
    let currentPalette = [];
    let nextPalette = [];
    let time = 0;

    function setup() {
      colorMode(RGB);
      w = windowWidth;
      h = windowHeight;
      createCanvas(w, h);
      cols = floor(w / scl) + 1;  
      rows = floor(h / scl) + 1;

      currentPalette = baseColors[currentPaletteIndex];
      nextPalette = baseColors[(currentPaletteIndex + 1) % baseColors.length];

      generateFlowField();
      generateTerrain();
      generateDots();
    }

    function draw() {
      background(0);
      drawTerrain();
      updateAndDisplayDots();

      time += 0.0165 * speedMultiplier;

      if (rainbowMode) {
        // Check if it's time to change the palette in rainbow mode
        if (millis() - lastPaletteChangeTime > RAINBOW_MODE_INTERVAL) {
          currentPaletteIndex = (currentPaletteIndex + 1) % baseColors.length;
          nextPalette = baseColors[(currentPaletteIndex + 1) % baseColors.length];
          lastPaletteChangeTime = millis();
        }
      } else {
        // Check if 'n' key is pressed to change the palette
        if (keyIsPressed && key === 'n') {
          currentPaletteIndex = (currentPaletteIndex + 1) % baseColors.length;
          nextPalette = baseColors[(currentPaletteIndex + 1) % baseColors.length];
        }
      }

      updatePalette();
      generateTerrain();
    }

    function drawTerrain() {
      noStroke();
      for (let y = 0; y < rows; y++) {
        beginShape(TRIANGLE_STRIP);
        for (let x = 0; x < cols; x++) {
          let currentHeight = terrain[x][y];
          let nextHeight = (y + 1 < rows) ? terrain[x][y + 1] : currentHeight;

          let currentColor = calculateColor(currentHeight);
          let nextColor = calculateColor(nextHeight);

          fill(lerpColor(currentColor, nextColor, 0.5));
          vertex(x * scl, y * scl, currentHeight);
          vertex(x * scl, (y + 1) * scl, nextHeight);
        }
        endShape();
      }
    }

    function updateAndDisplayDots() {
      for (let i = 0; i < dots.length; i++) {
        dots[i].update();
        dots[i].display();
      }
    }

    function calculateColor(height) {
      let t = map(height, 10, 150, 0, 1);
      return lerpColor(color(0, 0, 0), color(...currentPalette), t);
    }

    function generateDots() {
      dots = []; // Clear the array before regenerating
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          let index1 = x + y * cols;
          let index2 = (x + 1) + y * cols;
          let index3 = x + (y + 1) * cols;

          let center1 = createVector((x + 0.5) * scl, (y + 0.5) * scl, terrain[x][y]);
          let center2 = createVector((x + 1.5) * scl, (y + 0.5) * scl, (x + 1 < cols) ? terrain[x + 1][y] : terrain[x][y]);
          let center3 = createVector((x + 0.5) * scl, (y + 1.5) * scl, (y + 1 < rows) ? terrain[x][y + 1] : terrain[x][y]);

          dots.push(new ConnectedCurvedDot(flowfield[index1], center1, 0.2, 0.01, random(TWO_PI)));
          dots.push(new ConnectedCurvedDot(flowfield[index1], center2, 0.2, 0.01, random(TWO_PI)));

          if (x + 1 < cols) {
            dots.push(new ConnectedCurvedDot(flowfield[index1], center3, 0.2, 0.01, random(TWO_PI)));
          }
        }
      }
    }

    function generateTerrain() {
      for (let x = 0; x < cols; x++) {
        terrain[x] = [];
        for (let y = 0; y < rows; y++) {
          let noiseScale = 0.1;
          terrain[x][y] = map(noise(x * noiseScale, y * noiseScale, time), 0, 1, 55, 155) + sin(x * 0.1) * 20 + cos(y * 0.1) * 20;
        }
      }
    }

    function updatePalette() {
      for (let i = 0; i < currentPalette.length; i++) {
        currentPalette[i] = lerp(currentPalette[i], nextPalette[i], FADE_SPEED * speedMultiplier);
      }
    }

    class ConnectedCurvedDot {
      constructor(v, position, noiseScale, speed, angleOffset) {
        this.position = position.copy();
        this.noiseScale = noiseScale;
        this.speed = speed;
        this.angleOffset = angleOffset;
        this.time = 0;
        this.v = v;
        this.len = 10;
        this.alpha = MAX_ALPHA;
        this.fadeAlpha = 0;
      }

      update() {
        this.time += this.speed * speedMultiplier;
        this.fadeAlpha += FADE_SPEED * speedMultiplier;
        this.fadeAlpha = constrain(this.fadeAlpha, 0, MAX_ALPHA);
      }

      display() {
        push();
        translate(this.position.x, this.position.y, this.position.z);
        stroke(255, this.alpha);
        strokeWeight(2);
        fill(100, 200, 255, this.alpha);

        let cx1 = this.v.x * this.len + (noise(this.position.x * this.noiseScale, this.position.y * this.noiseScale, this.time + this.angleOffset) - 0.5) * 40;
        let cy1 = this.v.y * this.len + (noise(this.position.x * this.noiseScale + 5, this.position.y * this.noiseScale + 5, this.time + this.angleOffset) - 0.5) * 40;
        let cx2 = this.v.x * this.len * -1 + (noise(this.position.x * this.noiseScale + 10, this.position.y * this.noiseScale + 10, this.time + this.angleOffset) - 0.5) * 40;
        let cy2 = this.v.y * this.len * -1 + (noise(this.position.x * this.noiseScale + 15, this.position.y * this.noiseScale + 15, this.time + this.angleOffset) - 0.5) * 40;

        bezier(0, 0, cx1, cy1, cx2, cy2, this.len, 0);

        this.alpha = MAX_ALPHA - this.fadeAlpha;
        pop();
      }
    }

    function generateFlowField() {
      let yoff = 0;
      for (let y = 0; y < rows; y++) {
        let xoff = 0;
        for (let x = 0; x < cols; x++) {
          let index = x + y * cols;
          let angle = noise(xoff, yoff) * TWO_PI * 2;
          let v = p5.Vector.fromAngle(angle);
          flowfield[index] = v;
          xoff += NOISE_INCREMENT;
        }
        yoff += NOISE_INCREMENT;
      }
    }

    function keyPressed() {
      if (key === 'j') {
        speedMultiplier = min(2, speedMultiplier + SPEED_CHANGE_RATE);
      } else if (key === 'k') {
        speedMultiplier = max(0.5, speedMultiplier - SPEED_CHANGE_RATE);
      } else if (key === 'n') {
        currentPaletteIndex = (currentPaletteIndex + 1) % baseColors.length;
        nextPalette = baseColors[(currentPaletteIndex + 1) % baseColors.length];
      } else if (key === 'm') {
        rainbowMode = !rainbowMode; // Toggle rainbow mode
        lastPaletteChangeTime = millis();
      }
    }

    function windowResized() {
      w = windowWidth;
      h = windowHeight;
      resizeCanvas(w, h);

      cols = floor(w / scl) + 1;
      rows = floor(h / scl) + 1;

      generateFlowField();
      generateDots();
      generateTerrain();
    }
  </script>
</body>
</html>
